#lang typed/racket/no-check
; WARNING: Doesn't work without no-check. I can only guess that `cast` doesn't throw but
; fails in some way that fails a result instead, resulting in no bindings.
; nb (require minikanren) should provide all this code
(define var vector)
(define var? vector?)
(define-type (Tree a) (Listof (U a (Tree a))))
(define-type Var (Mutable-Vectorof Symbol))
(define-type Str (U #f Subst (Pair Subst (-> Str))))
(define-type Goal (-> Subst Str))
(define-type Data (U Var Output (Pair Data Data)))
(define-type Output (U Integer Symbol (Tree Symbol)))
(define-type Subst (Listof (Pair Var Data)))
(define lhs car)
(define rhs cdr)
(define empty-s '())
(: ext-s (-> Var Data Subst Subst))
(define (ext-s x v s)
  (cons (cons x v) s))
(define size-s length)
(define-syntax run
    (syntax-rules ()
        ((_ n^ (x) g ...)
         (let ((n n^) (x (var 'x)))
           (if (or (not n) (> n 0))
             (map-inf n (lambda ([s : Subst]) (cast (reify (walk* x s)) Output)) ((all g ...) empty-s))
             '())))))
(: walk* (-> Data Subst Data))
(define (walk* v s)
  (let ((v (walk v s)))
    (cond
      ((var? v) v)
      ((pair? v) (cast (cons (walk* (car v) s) (walk* (cdr v) s)) (Tree Symbol)))
      (else v))))
(: walk (Data Subst -> Data))
(define (walk v s)
  (cond
    ((var? v) (cond
                ((assq v s) => (lambda (a) (walk (rhs a) s)))
                (else v)))
    (else v)))
(: reify (Data -> Data))
(define (reify v)
  (walk* v (reify-s v empty-s)))
(: reify-s (-> Data Subst Subst))
(define (reify-s v s)
  (let ((v (walk v s)))
    (cond
      ((var? v) (ext-s v (reify-name (size-s s)) s))
      ((pair? v) (reify-s (cdr v) (reify-s (car v) s)))
      (else s))))
(: reify-name (-> Integer Symbol))
(define (reify-name n)
  (string->symbol (string-append "_" "." (number->string n))))
(define-syntax case-inf
  (syntax-rules ()
    ((_ e on-zero ((a^) on-one) ((a f) on-choice))
     (let ((a-inf e))
       (cond
         ((not a-inf) on-zero)
         ((not (and (pair? a-inf) (procedure? (cdr a-inf))))
          (let ((a^ a-inf))
            on-one))
         (else (let ((a (car a-inf)) (f (cdr a-inf)))
                 on-choice)))))))
(define-syntax mzero
  (syntax-rules ()
    ((_) #f)))
(define-syntax unit
  (syntax-rules ()
    ((_ a) a)))
(define-syntax choice
  (syntax-rules ()
    ((_ a f) (cons a f))))
(: map-inf ((U #f Integer) (Subst -> Output) Str -> (Listof Output)))
(define (map-inf n p a-inf)
    (case-inf a-inf
      '()
      ((a) (list (p (cast a Subst))))
      ((a f) (cons (p a)
                (cond
                  ((not n) (map-inf n p (f)))
                  ((> n 1) (map-inf (sub1 n) p (f)))
                  (else '()))))))
(: succeed Goal)
(define (succeed s) (unit s))
(: succeed Goal)
(define fail (lambda (s) (mzero)))
(: == (-> Data Data Goal))
(define (== v w)
  (lambda ([s : Subst])
    (cond
      ((unify v w s) => succeed)
      (else (fail s)))))
(: unify (-> Data Data Subst (U Subst #f)))
(define (unify v w s)
  (let ((v (walk v s)) (w (walk w s)))
    (cond
      ((eq? v w) s)
      ((var? v) (ext-s v w s))
      ((var? w) (ext-s w v s))
      ((and (pair? v) (pair? w))
       (cond
         ((unify (car v) (car w) s) => (lambda (s) (unify (cdr v) (cdr w) s)))
         (else #f)))
      ((equal? v w) s)
      (else #f))))
(define-syntax fresh
  (syntax-rules ()
    ((_ (x ...) g ...)
     (lambda ([s : Subst])
       (let ((x (var 'x)) ...)
         ((all g ...) s))))))
(define-syntax conde
  (syntax-rules ()
    ((_ c ...) (cond-aux ife c ...))))
(define-syntax cond-aux
  (syntax-rules (else)
    ((_ _) fail)
    ((_ _ (else g ...)) (all g ...))
    ((_ _ (g ...)) (all g ...))
    ((_ ifer (g0 g ...) c ...)
     (ifer g0
       (all g ...)
       (cond-aux ifer c ...)))))
(define-syntax ife
  (syntax-rules ()
    ((_ g0 g1 g2)
     (lambda (s)
       (mplus ((all g0 g1) s) (lambda () (g2 s)))))))
(define-syntax all
    (syntax-rules ()
        ((_ g ...) (all-aux bind g ...))))
(define-syntax all-aux
    (syntax-rules ()
      ((_ _) succeed)
      ((_ _ g) g)
      ((_ bnd g0 g ...)
       (let ((g^ g0))
         (lambda (s)
           (bnd (g^ s) (lambda (s) ((all-aux bnd g ...) s))))))))
(: mplus (-> Str (-> Str) Str))
(define (mplus a-inf f)
  (case-inf a-inf
    (f)
    ((a) (choice (cast a Subst) f))
    ((a f0) (choice a (lambda () (mplus (f0) f))))))
(: bind (-> Str (-> Str Str) Str))
(define (bind a-inf g)
  (case-inf a-inf
    (mzero)
    ((a) (g a))
    ((a f) (mplus (g a) (lambda () (bind (f) g))))))
(: conso (Data Data Data -> Goal))
(define (conso a d p)
  (== (cons a d) p))
(: caro (Data Data -> Goal))
(define (caro a p)
  (fresh (d)
    (conso a d p)))
(: cdro (Data Data -> Goal))
(define (cdro d p)
  (fresh (a)
    (conso a d p)))
(: pairo (Data -> Goal))
(define (pairo p)
  (fresh (a d)
    (conso a d p)))
(: nullo (Data -> Goal))
(define (nullo p)
  (== '() p))
(run #f (q) (conso 1 '(2) q))