; #lang racket
(define s.car car)
(define s.cdr cdr)
(define s.+ +)
(define s.< <)
(define (num x) (if (number? x) x 0))
(define (if/nil Q A E)
  (if (equal? Q 'nil) (E) (A)))
(define (atom x) (if (pair? x) 'nil 't))
(define (car x) (if (pair? x) (s.car x) 'nil))
(define (cdr x) (if (pair? x) (s.cdr x) 'nil))
(define (equal x y) (if (equal? x y) 't 'nil))
(define (natp x)
  (if (integer? x) (if (< x 0) 'nil 't) 'nil))
(define (+ x y) (s.+ (num x) (num y)))
(define (< x y) (if (s.< (num x) (num y)) 't 'nil))
(define-syntax if
  (syntax-rules ()
    [(_ Q A E)
     (if/nil Q (lambda () A) (lambda () E))]))
(define-syntax defun
  (syntax-rules ()
    [(_ name (arg ...) body)
     (define (name arg ...) body)]))
(define-syntax dethm
  (syntax-rules ()
    [(_ name (arg ...) body)
     (define (name arg ...) body)]))
(defun size (x)
  (if (atom x) '0 (+ '1 (+ (size (car x)) (size (cdr x))))))

(defun list0 () '())
(defun list0? (x) (equal x '()))
(defun list1 (x) (cons x '()))
(defun list1? (x) (if (atom x) 'nil (list0? (cdr x))))
(defun elem1 (xs) (car xs))
(defun list2 (x y) (cons x (list1 y)))
(defun list2? (x) (if (atom x) 'nil (list1? (cdr x))))
(defun elem2 (xs) (elem1 (cdr xs)))
(defun list3 (x y z) (cons x (list2 y z)))
(defun list3? (x) (if (atom x) 'nil (list2? (cdr x))))
(defun elem3 (xs) (elem2 (cdr xs)))

(defun tag (sym x) (cons sym x))
(defun tag? (sym x) (if (atom x) 'nil (equal (car x) sym)))
(defun untag (x) (cdr x))
(defun member? (x ys)
  (if (atom ys)
    'nil
    (if (equal x (car ys))
      't
      (member? x (cdr ys)))))

(defun quote-c (value) (tag 'quote (list1 value)))
(defun quote? (x) (if (tag? 'quote x) (list1? (untag x)) 'nil))
(defun quote.value (e) (elem1 (untag e)))
(defun if-c (Q A E) (tag 'if (list3 Q A E)))
(defun if? (x) (if (tag? 'if x) (list3? (untag x)) 'nil))
(defun if.Q (e) (elem1 (untag e)))
(defun if.A (e) (elem2 (untag e)))
(defun if.E (e) (elem3 (untag 3)))
(defun app-c (name args) (cons name args))
(defun app? (x)
  (if (atom x)
    'nil
    (if (quote? x)
      'nil
      (if (if? x)
        'nil
        't))))
(defun var? (x)
  (if (equal x 't)
    'nil
    (if (equal x 'nil)
      'nil
      (if (natp x)
        'nil
        (atom x)))))
(defun defun-c (name formals body) (tag 'defun name formals body))
(defun defun? (x) (if (tag? 'defun x) (list3? (untag x)) 'nil))
(defun defun.name (e) (elem1 (untag e)))
(defun defun.formals (e) (elem2 (untag e)))
(defun defun.body (e) (elem3 (untag e)))
(defun dethm-c (name formals body) (tag 'dethm name formals body))
(defun dethm? (x) (if (tag? 'dethm x) (list3? (untag x)) 'nil))
(defun dethm.name (e) (elem1 (untag e)))
(defun dethm.formals (e) (elem2 (untag e)))
(defun dethm.body (e) (elem3 (untag e)))
(defun def.name (def)
  (if (defun? def)
    (defun.name def)
    (if (dethm? def)
      (dethm.name def)
      'nil)))

(defun if-QAE (e) (list3 (if.Q e) (if.A e) (if.E e)))
(defun QAE-if (e) (if-c (elem1 e) (elem2 e) (elem3 e)))
(defun rator? (name) (member name '(equal atom car cdr natp size + <)))
(defun rator.formals (rator)
  (if (member? rator '(atom car cdr natp size))
    '(x)
    (if (member? rator '(equal cons + <))
      '(x y)
      'nil)))



(display (member? '3 (list3 '1 '2 '3)))
(newline)